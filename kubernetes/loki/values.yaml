loki:
  server:
    log_level: warn
    log_format: json

  schemaConfig:
    configs:
    - from: "2024-04-01"
      store: tsdb
      object_store: s3
      schema: v13
      index:
        prefix: loki_index_
        period: 24h

  storage:
    type: s3
    bucketNames:
      chunks: ""
      ruler: ""
      admin: ""
    s3:
      region: us-east-1
      s3forcepathstyle: false

  ui:
    enabled: true

  limits_config:
    ingestion_rate_mb: 2048
    ingestion_burst_size_mb: 4096
    max_line_size: 1048576
    allow_structured_metadata: true
    volume_enabled: true
    reject_old_samples: true
    reject_old_samples_max_age: 168h # 7 dias
    max_cache_freshness_per_query: 10m
    per_stream_rate_limit: 30MB
    per_stream_rate_limit_burst: 50MB
    max_entries_limit_per_query: 10000
    max_global_streams_per_user: 10000
    max_query_lookback: 365d
    max_query_parallelism: 512
    split_queries_by_interval: 2h
    max_query_series: 100000
    query_timeout: 5m
    max_query_bytes_read: 150GB
    max_querier_bytes_read: 150GB
    retention_period: 0h
    tsdb_max_bytes_per_shard: 256MB
    tsdb_max_query_parallelism: 2048

  structuredConfig:
    chunk_store_config:
      chunk_cache_config:
        default_validity: 1h
        redis:
          endpoint: 
          db: 0
          timeout: 2s
          pool_size: 20
          tls_enabled: true
          tls_insecure_skip_verify: true
    storage_config:
      index_queries_cache_config:
        embedded_cache:
          enabled: false
        redis:
          endpoint: 
          db: 6
          timeout: 2s
          pool_size: 20
          tls_enabled: true
          tls_insecure_skip_verify: true
      bloom_shipper:
        metas_cache:
          redis:
            endpoint: 
            db: 7
            timeout: 2s
            pool_size: 20
            tls_enabled: true
            tls_insecure_skip_verify: true

  query_range:
    cache_results: true
    cache_instant_metric_results: true
    align_queries_with_step: true
    results_cache:
      cache:
        default_validity: 12h
        redis:
          endpoint: 
          db: 0
          timeout: 2s
          pool_size: 20
          tls_enabled: true
          tls_insecure_skip_verify: true
    index_stats_results_cache:
      cache:
        default_validity: 12h
        redis:
          endpoint: 
          db: 1
          timeout: 2s
          pool_size: 20
          tls_enabled: true
          tls_insecure_skip_verify: true
    volume_results_cache:
      cache:
        default_validity: 12h
        redis:
          endpoint: 
          db: 2
          timeout: 2s
          pool_size: 20
          tls_enabled: true
          tls_insecure_skip_verify: true
    instant_metric_results_cache:
      cache:
        default_validity: 12h
        redis:
          endpoint: 
          db: 3
          timeout: 2s
          pool_size: 20
          tls_enabled: true
          tls_insecure_skip_verify: true
    series_results_cache:
      cache:
        default_validity: 12h
        redis:
          endpoint: 
          db: 4
          timeout: 2s
          pool_size: 20
          tls_enabled: true
          tls_insecure_skip_verify: true
    label_results_cache:
      cache:
        default_validity: 12h
        redis:
          endpoint: 
          db: 5
          timeout: 2s
          pool_size: 20
          tls_enabled: true
          tls_insecure_skip_verify: true

  ingester:
    chunk_encoding: snappy
    max_chunk_age: 1h
    lifecycler:
      ring:
        # 'memberlist' é usado para que os ingesters se descubram
        # e formem o anel de consistência.
        replication_factor: 3 # Mudar conforme quantidade de pods no Statefulset
        kvstore:
          store: memberlist
    wal:
      enabled: true
      checkpoint_duration: 5m0s
      dir: /var/loki/wal
      flush_on_shutdown: true
      replay_memory_ceiling: 3GB
  
  pattern_ingester:
    enabled: true

  compactor:
    retention_enabled: true
    delete_request_store: s3

  ruler:
    enable_api: true

  querier:
    max_concurrent: 15

serviceAccount:
  create: true
  annotations:
    "eks.amazonaws.com/role-arn": "arn:aws:iam:::role/LokiServiceAccountRole"

deploymentMode: Distributed

ingester:
  kind: StatefulSet
  # IMPORTANTE: O número de réplicas agora deve ser um múltiplo 
  # do número de AZs que você usa. Ex: 2 réplicas por zona em 3 zonas = 6 réplicas.
  # O Helm chart vai dividir isso entre as zonas.
  replicas: 6
  zoneAwareReplication:
    enabled: false
  nodeSelector:
    karpenter.sh/nodepool: general
    topology.kubernetes.io/zone: us-east-1a
  podAnnotations:
    karpenter.sh/do-not-disrupt: "true"
  affinity:
    podAntiAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        - labelSelector:
            matchLabels:
              app.kubernetes.io/name: loki
              app.kubernetes.io/component: ingester
          topologyKey: "kubernetes.io/hostname"
  resources:
    limits:
      cpu: "1"
      memory: "4Gi"
    requests:
      cpu: "1"
      memory: "3Gi"

compactor:
  replicas: 3
  nodeSelector:
    karpenter.sh/nodepool: general-ondemand #On-demand em prod
  podAnnotations:
    karpenter.sh/do-not-disrupt: "true"

distributor:
  replicas: 3
  maxUnavailable: 2
  nodeSelector:
    karpenter.sh/nodepool: general
  podAnnotations:
    karpenter.sh/do-not-disrupt: "true"
  affinity:
    podAntiAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        - labelSelector:
            matchLabels:
              app.kubernetes.io/name: loki
              app.kubernetes.io/component: distributor
          topologyKey: "kubernetes.io/hostname"

querier:
  replicas: 4
  maxUnavailable: 2
  nodeSelector:
    karpenter.sh/nodepool: general
  affinity:
    podAntiAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        - labelSelector:
            matchLabels:
              app.kubernetes.io/name: loki
              app.kubernetes.io/component: querier
          topologyKey: "kubernetes.io/hostname"
  resources:
    limits:
      cpu: "1"
      memory: "4Gi"
    requests:
      cpu: "700m"
      memory: "3Gi"
  autoscaling:
    enabled: true
    minReplicas: 4
    maxReplicas: 15
    targetCPUUtilizationPercentage: 70
    targetMemoryUtilizationPercentage: 80

queryFrontend:
  replicas: 6
  maxUnavailable: 2
  nodeSelector:
    karpenter.sh/nodepool: general

queryScheduler:
  replicas: 2
  nodeSelector:
    karpenter.sh/nodepool: general

indexGateway:
  replicas: 2
  maxUnavailable: 1
  nodeSelector:
    karpenter.sh/nodepool: general

ruler:
  replicas: 1
  maxUnavailable: 1
  nodeSelector:
    karpenter.sh/nodepool: general

# Desabilitando componentes não utilizados no modo distribuído
minio:
  enabled: false
backend:
  replicas: 0
read:
  replicas: 0
write:
  replicas: 0
singleBinary:
  replicas: 0

#desabilita caches como POD no K8S
chunksCache:
  enabled: false
resultsCache:
  enabled: false
indexCache:
  enabled: false
metadataCache:
  enabled: false