apiVersion: v1
kind: ConfigMap
metadata:
  name: alloy-configmap
  namespace: monitoring
data:
  config.alloy: |-
    // Listening do Alloy
    otelcol.receiver.otlp "otlp_receiver" {
      grpc {
        endpoint = "0.0.0.0:4317"
        include_metadata = true
      }

      http {
        endpoint = "0.0.0.0:4318"
        include_metadata = true
      }
    
      output {
        traces = [otelcol.processor.k8sattributes.grafana_tempo.input]
      }
    }

    // Metadata para o APM
    otelcol.processor.k8sattributes "grafana_tempo" {
      auth_type = "serviceAccount"
      wait_for_metadata = true

      extract {
        label {
          from      = "pod"
          key_regex = "(.*)/(.*)"
          tag_name  = "$1.$2"
        }

        metadata = [
          "k8s.namespace.name",
          "k8s.node.name",
          "k8s.deployment.name",
          "k8s.pod.name",
          "k8s.pod.start_time",
          "k8s.container.name",
          "container.id",
          "container.image.name",
        ]
      }

      output {
        traces = [otelcol.processor.memory_limiter.grafana_tempo.input]
      }
    }

    // Queue para ser enviada para o APM
    otelcol.processor.memory_limiter "grafana_tempo" {
      check_interval = "3s"
      limit          = "256MiB"


      output {
        traces = [otelcol.exporter.otlp.grafana_tempo.input]
      }
    }

    // Envio de métricas do APM
    otelcol.exporter.otlp "grafana_tempo" {
      client {
        endpoint = "distributor-service:4317"
        tls {
    			insecure = true
    		}
      }

      sending_queue {
        enabled = true
        num_consumers = 20
        queue_size = 3000
      }
    }
    ////////////////////////////////////////////////////////////////////////

    // Descobrir os nós do Kubernetes.
    discovery.kubernetes "k8s_nodes" {
        role = "node"
    }

    // Coleta métricas de Node. Expõe o endpoint para realizar o scrape
    prometheus.exporter.unix "node_metrics_collector" {}

    // Relabel adress
    discovery.relabel "relabel_adress" {
      targets = discovery.kubernetes.k8s_nodes.targets

      // Regra para manter apenas o alvo cujo nome do nó corresponde à variável de ambiente.
      rule {
        action        = "keep"
        source_labels = ["__meta_kubernetes_node_name"]
        regex         = env("HOSTNAME")
      }

      // Transforma as meta-labels de node em labels permanentes
      rule {
        action  = "labelmap"
        // Este regex encontra todas as labels que começam com '__meta_kubernetes_node_label_'
        // e captura (a parte em parênteses) todo o resto do nome da label.
        regex   = "__meta_kubernetes_node_label_(.+)"
        // A ação labelmap então cria uma nova label usando o texto capturado ($1)
        // e atribui a ela o valor da label original.
      }

      rule {
        action       = "replace"
        source_labels = ["__address__"]
        target_label = "__address__"
        replacement  = "alloy.internal:12345"
      }
    }

    // Realiza o scrape nas métricas de nodes
    prometheus.scrape "metrics_node" {
      targets = discovery.relabel.relabel_adress.output

      metrics_path = "/api/v0/component/prometheus.exporter.unix.node_metrics_collector/metrics"

      forward_to = [prometheus.relabel.general_labels.receiver]
    }

    ////////////////////////////////////////////////////////////////////////

    // Coleta métricas de Pod
    prometheus.exporter.cadvisor "cadvisor" {
      enabled_metrics = ["app","cpu","cpuLoad","percpu","memory","oom_event","diskIO","disk","network"]
    }
    
    // Realiza o scrape nas métricas de pods
    prometheus.scrape "metrics_pods" {
      targets    = prometheus.exporter.cadvisor.cadvisor.targets
      forward_to = [prometheus.relabel.keep_pod_metrics.receiver]
    }

    prometheus.relabel "keep_pod_metrics" {
      rule {
        action        = "keep"
        source_labels = ["id"]
        regex         = "/kubepods.slice/.+"
      }

      rule {
        action        = "keep"
        source_labels = ["image"]
        regex         = ".+"
      }

      forward_to = [prometheus.relabel.general_labels.receiver]
    }

    ////////////////////////////////////////////////////////////////////////

    // Loki
    discovery.kubernetes "pods" {
      role = "pod"
    }
    
    discovery.relabel "pod_logs" {
      targets = discovery.kubernetes.pods.targets

      // Essential K8s Labels (add/remove as needed)
      rule {
        source_labels = ["__meta_kubernetes_namespace"]
        action        = "replace"
        target_label  = "namespace"
      }

      rule {
        source_labels = ["__meta_kubernetes_pod_container_name"]
        action        = "replace"
        target_label  = "container"
      }

      // Adiciona o nome do nó como uma label temporária
      rule {
        source_labels = ["__meta_kubernetes_pod_node_name"]
        action        = "replace"
        target_label  = "node_name"
      }

      // Adiciona o "dono" do pod (Deployment, StatefulSet, etc.) como label temporária
      rule {
        source_labels = ["__meta_kubernetes_pod_owner"]
        action        = "replace"
        target_label  = "pod_owner"
      }

      // Adiciona o IP do Pod como label temporária
      rule {
        source_labels = ["__meta_kubernetes_pod_ip"]
        action        = "replace"
        target_label  = "pod_ip"
      }

      rule {
        action = "replace"
        target_label = "cluster_name"
        replacement = ""
      }
    }

    loki.source.kubernetes "pods" {
      targets    = discovery.relabel.pod_logs.output
      forward_to = [loki.process.add_k8s_metadata.receiver]
    }

    // Transforma labels em metadados
    loki.process "add_k8s_metadata" {
      // O stage.pack cria um novo log em formato JSON
      stage.pack {
        // Especifica quais labels devem ser adicionadas como campos no novo JSON.
        labels = ["node_name", "pod_owner", "pod_ip"]

        // O log original será colocado dentro de uma chave chamada "log".
        ingest_timestamp = false // Vamos manter o timestamp original do log
      }

      // Envia os logs processados para o próximo estágio (seu filtro de health checks)
      forward_to = [loki.process.filter_health_checks.receiver]
    }

    // Remove logs de healthckecks
    loki.process "filter_health_checks" {
      // Estágio 1: Analisa a linha de log como JSON.
      stage.json {
        expressions = {
          nested_agent = "log.details.headers.\"user-agent\"",
          root_agent   = "log.agent",
        }
      }

      // Estágio 2: Cria um novo campo unificado 'effective_agent'.
      // A função 'coalesce' retorna o primeiro valor não vazio da lista.
      stage.template {
        source   = "effective_agent"
        template = "{{ coalesce .nested_agent .root_agent }}"
      }

      // Estágio 3: Descarta o log com base no campo unificado.
      stage.drop {
        // A fonte agora é o campo que criamos no estágio anterior.
        source     = "effective_agent"
        expression = ".*(ELB-HealthChecker|kube-probe).*"
        drop_counter_reason = "health_check"
      }

      forward_to = [loki.relabel.remove_default.receiver]
    }

    loki.relabel "remove_default" {
      rule {
        action = "labeldrop"
        regex  = "instance|service_name|job"
      }

      forward_to = [loki.write.loki_cluster.receiver]
    }

    loki.write "loki_cluster" {
      endpoint {
        url = "http://loki-gateway.loki.svc.cluster.local/loki/api/v1/push"
        tenant_id = "fake"
      }
    }

    ////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////

    // Adiciona labels do Kubernetes. Todas as outras prometheus.relabel devem redirecionar para aqui
    prometheus.relabel "general_labels" {
      rule {
        action = "replace"
        target_label = "cluster_name"
        replacement = ""
      }

      forward_to = [prometheus.remote_write.prometheus_metrics.receiver]
    }

    // Componente de escrita remota para o Prometheus Metrics
    prometheus.remote_write "prometheus_metrics" {
      endpoint {
        url = "http://prometheus-metrics-service:9090/api/v1/write"
      }
    }

    // Log level do Alloy
    logging {
      level  = "error"
      format = "json"
    }

    // Debug no frontend
    livedebugging {
      enabled = true
    }