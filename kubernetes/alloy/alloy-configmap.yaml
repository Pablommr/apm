apiVersion: v1
kind: ConfigMap
metadata:
  name: alloy-configmap
  namespace: monitoring
data:
  config.alloy: |-
    // Listening do Alloy
    otelcol.receiver.otlp "otlp_receiver" {
      grpc {
        endpoint = "0.0.0.0:4317"
        include_metadata = true
      }

      http {
        endpoint = "0.0.0.0:4318"
        include_metadata = true
      }
    
      output {
        traces = [otelcol.processor.k8sattributes.grafana_tempo.input]
      }
    }

    // Metadata para o APM
    otelcol.processor.k8sattributes "grafana_tempo" {
      auth_type = "serviceAccount"
      wait_for_metadata = true

      extract {
        label {
          from      = "pod"
          key_regex = "(.*)/(.*)"
          tag_name  = "$1.$2"
        }

        metadata = [
          "k8s.namespace.name",
          "k8s.node.name",
          "k8s.deployment.name",
          "k8s.pod.name",
          "k8s.pod.start_time",
          "k8s.container.name",
          "container.id",
          "container.image.name",
        ]
      }

      output {
        traces = [otelcol.processor.memory_limiter.grafana_tempo.input]
      }
    }

    // Queue para ser enviada para o APM
    otelcol.processor.memory_limiter "grafana_tempo" {
      check_interval = "3s"
      limit          = "256MiB"


      output {
        traces = [otelcol.exporter.otlp.grafana_tempo.input]
      }
    }

    // Envio de métricas do APM
    otelcol.exporter.otlp "grafana_tempo" {
      client {
        endpoint = "distributor-service:4317"
        tls {
    			insecure = true
    		}
      }

      sending_queue {
        enabled = true
        num_consumers = 20
        queue_size = 3000
      }
    }
    ////////////////////////////////////////////////////////////////////////

    // Descobrir os nós do Kubernetes.
    discovery.kubernetes "k8s_nodes" {
        role = "node"
    }

    // Coleta métricas de Node. Expõe o endpoint para realizar o scrape
    prometheus.exporter.unix "node_metrics_collector" {}

    // Relabel adress
    discovery.relabel "relabel_adress" {
      targets = discovery.kubernetes.k8s_nodes.targets

      // Regra para manter apenas o alvo cujo nome do nó corresponde à variável de ambiente.
      rule {
        action        = "keep"
        source_labels = ["__meta_kubernetes_node_name"]
        regex         = env("HOSTNAME")
      }

      // Transforma as meta-labels de node em labels permanentes
      rule {
        action  = "labelmap"
        // Este regex encontra todas as labels que começam com '__meta_kubernetes_node_label_'
        // e captura (a parte em parênteses) todo o resto do nome da label.
        regex   = "__meta_kubernetes_node_label_(.+)"
        // A ação labelmap então cria uma nova label usando o texto capturado ($1)
        // e atribui a ela o valor da label original.
      }

      rule {
        action       = "replace"
        source_labels = ["__address__"]
        target_label = "__address__"
        replacement  = "alloy.internal:12345"
      }
    }

    // Realiza o scrape nas métricas de nodes
    prometheus.scrape "metrics_node" {
      targets = discovery.relabel.relabel_adress.output

      metrics_path = "/api/v0/component/prometheus.exporter.unix.node_metrics_collector/metrics"

      forward_to = [prometheus.relabel.general_labels.receiver]
    }

    ////////////////////////////////////////////////////////////////////////

    // Coleta métricas de Pod
    prometheus.exporter.cadvisor "cadvisor" {
      enabled_metrics = ["app","cpu","cpuLoad","percpu","memory","oom_event","diskIO","disk","network"]
    }
    
    // Realiza o scrape nas métricas de pods
    prometheus.scrape "metrics_pods" {
      targets    = prometheus.exporter.cadvisor.cadvisor.targets
      forward_to = [prometheus.relabel.keep_pod_metrics.receiver]
    }

    prometheus.relabel "keep_pod_metrics" {
      rule {
        action        = "keep"
        source_labels = ["id"]
        regex         = "/kubepods.slice/.+"
      }

      rule {
        action        = "keep"
        source_labels = ["image"]
        regex         = ".+"
      }

      forward_to = [prometheus.relabel.general_labels.receiver]
    }

    ////////////////////////////////////////////////////////////////////////

    // Loki
    discovery.kubernetes "pods" {
      role = "pod"
    }

    // Garante que cada agent do alloy só colete informações de pods que estão em seu próprio node.
    discovery.relabel "filter_pods_by_node" {
      targets = discovery.kubernetes.pods.targets

      rule {
        action        = "keep"
        source_labels = ["__meta_kubernetes_pod_node_name"]
        // 'HOSTNAME' deve ser passado para o pod do Alloy
        // via Downward API ou similar.
        regex         = env("HOSTNAME")
      }
    }

    // Remove logs indesejados
    discovery.relabel "drop_pod_logs" {
      targets = discovery.relabel.filter_pods_by_node.output

      rule {
        source_labels = ["__meta_kubernetes_pod_controller_name"]
        action        = "drop"
        regex         = "loki-canary"
      }

      rule {
        source_labels = ["__meta_kubernetes_pod_controller_name"]
        action        = "drop"
        regex         = "loki-gateway-.*"
      }

    }
    
    discovery.relabel "pod_logs" {
      targets = discovery.relabel.drop_pod_logs.output

      // Regra 1 (O Fallback): Define o nome do container como o service_name padrão.
      // Esta regra será executada para todos os pods.
      rule {
        source_labels = ["__meta_kubernetes_pod_container_name"]
        action        = "replace"
        target_label  = "service_name"
      }

      // Regra 2 (A Prioridade): Se a label 'app' existir, ela sobrescreve o fallback.
      // O regex "(.+)" garante que esta regra só seja acionada se a label não estiver vazia.
      rule {
        source_labels = ["__meta_kubernetes_pod_label_app"]
        regex         = "(.+)" 
        action        = "replace"
        target_label  = "service_name"
      }

      // Essential K8s Labels (add/remove as needed)
      rule {
        source_labels = ["__meta_kubernetes_namespace"]
        action        = "replace"
        target_label  = "namespace"
      }

      rule {
        source_labels = ["__meta_kubernetes_pod_name"]
        action        = "replace"
        target_label  = "pod_name"
      }

      rule {
        source_labels = ["__meta_kubernetes_pod_phase"]
        action        = "replace"
        target_label  = "pod_phase"
      }

      rule {
        source_labels = ["__meta_kubernetes_pod_ready"]
        action        = "replace"
        target_label  = "pod_ready"
      }

      rule {
        source_labels = ["__meta_kubernetes_pod_container_name"]
        action        = "replace"
        target_label  = "container_name"
      }

      rule {
        source_labels = ["__meta_kubernetes_pod_container_image"]
        action        = "replace"
        target_label  = "image"
      }

      rule {
        source_labels = ["__meta_kubernetes_pod_controller_kind"]
        action        = "replace"
        target_label  = "controller_kind"
      }

      rule {
        source_labels = ["__meta_kubernetes_pod_controller_name"]
        action        = "replace"
        target_label  = "controller_name"
      }

      // Adiciona o nome do nó como uma label temporária
      rule {
        source_labels = ["__meta_kubernetes_pod_node_name"]
        action        = "replace"
        target_label  = "node_name"
      }

      // Adiciona o "dono" do pod (Deployment, StatefulSet, etc.) como label temporária
      rule {
        source_labels = ["__meta_kubernetes_pod_owner"]
        action        = "replace"
        target_label  = "pod_owner"
      }

      rule {
        action = "replace"
        target_label = "cluster_name"
        replacement = ""
      }
    }

    loki.source.kubernetes "pods" {
      targets    = discovery.relabel.pod_logs.output
      forward_to = [loki.process.filter_logs.receiver]
    }

    
    loki.process "filter_logs" {
      // Ignora logs antigos
      stage.drop {
        older_than          = "12h" // Configurar conforme reject_old_samples_max_age do Loki
        drop_counter_reason = "log too old"
      }

      // Remove última quebra de linha
      stage.replace {
        expression = "(\r?\n)$"
        replace    = ""
      }

      // Formata logs que não estão em formatos JSON
      stage.replace {
        // Regex: "Início da linha (^) que NÃO (!) começa com '{',
        // e capture (.*) tudo até o fim ($)."
        expression = "^($|[^{].*|.*[^}]$)"

        // Substitui a linha inteira pelo JSON,
        // colocando o grupo capturado ($1) como o valor da chave "log".
        // NOTA: É preciso escapar as aspas e a barra invertida
        replace = "{\"log_is_not_in_json\":\"{{ .Value }}\"}"
      }

      // Estágio 1: Analisa o JSON
      stage.json {
        expressions = {
          custom_user_agent_hyphen = "custom.\"user-agent\"",
          custom_user_agent_underscore = "custom.user_agent",
          header_user_agent_hyphen = "details.headers.\"user-agent\"",
          header_user_agent_underscore = "details.headers.user_agent",
          http_header_agent = "headers.HTTP_USER_AGENT",
          root_agent   = "agent",
          root_controller  = "controller",
        }
      }

      // Estágio 2: Cria um novo campo unificado 'effective_agent'.
      // A função 'coalesce' retorna o primeiro valor não vazio da lista.
      stage.template {
        source   = "effective_agent"
        template = "{{ coalesce .custom_user_agent_hyphen .custom_user_agent_underscore .header_user_agent_hyphen .header_user_agent_underscore .http_header_agent .root_agent .root_controller }}"
      }

      // Estágio 3: Descarta o log com base no campo unificado.
      stage.drop {
        // A fonte agora é o campo que criamos no estágio anterior.
        source     = "effective_agent"
        expression = ".*(ELB|HealthCheck|kube-probe).*"
        drop_counter_reason = "health_check"
      }

      stage.structured_metadata {
        values = {
          "pod_name" = "",
          "pod_phase" = "",
          "pod_ready" = "",
          "container_name" = "",
          "image" = "",
          "controller_kind" = "",
          "controller_name" = "",
          "node_name" = "",
          "pod_owner" = "",
        }
      }

      forward_to = [loki.relabel.keep_essential_labels.receiver]
    }

    // Mantém apenas as labels essenciais
    loki.relabel "keep_essential_labels" {
      rule {
        action = "labelkeep"
        regex  = "cluster_name|namespace|service_name"
      }

      forward_to = [loki.write.loki_cluster.receiver]
    }

    loki.write "loki_cluster" {
      endpoint {
        url = "http://loki-gateway.loki.svc.cluster.local/loki/api/v1/push"
        tenant_id = "fake"
      }
    }

    ////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////

    // Adiciona labels do Kubernetes. Todas as outras prometheus.relabel devem redirecionar para aqui
    prometheus.relabel "general_labels" {
      rule {
        action = "replace"
        target_label = "cluster_name"
        replacement = ""
      }

      forward_to = [prometheus.remote_write.prometheus_metrics.receiver]
    }

    // Componente de escrita remota para o Prometheus Metrics
    prometheus.remote_write "prometheus_metrics" {
      endpoint {
        url = "http://prometheus-metrics-service:9090/api/v1/write"
      }
    }

    // Log level do Alloy
    logging {
      level  = "error"
      format = "json"
    }

    // Debug no frontend
    livedebugging {
      enabled = true
    }